"use client"

import { useEffect, useRef, useState } from "react"
import { Button } from "@/components/ui/button"

// Game constants
const GAME_WIDTH = 640
const GAME_HEIGHT = 480
const PLAYER_SIZE = 16
const BULLET_SIZE = 4
const SEGMENT_SIZE = 16
const MUSHROOM_SIZE = 16 // Smaller eggs
const SECTION_SIZE = 4 // Smaller sections for more pixelated look
const PLAYER_SPEED = 5
const BULLET_SPEED = 8
const SEGMENT_SPEED = 2
const SPIDER_SIZE = 20
const BORDER_WIDTH = 16
const GRID_SIZE = SEGMENT_SIZE // Using segment size as grid size
const PARTICLE_SIZE = 1.5 // Smaller particles
const PARTICLE_COUNT = 4 // More particles for better effect
const BULLET_RADIUS = 6 // Larger hit radius for bullets
const MUSHROOM_FALL_CHANCE = 0.01 // Chance for a mushroom to start falling each frame
const MUSHROOM_FALL_SPEED = 1 // Speed at which mushrooms fall

// Egg colors for the mushroom blocks
const EGG_COLORS = [
  ["#8B4513", "#A52A2A", "#CD853F", "#D2691E"], // Brown variants
  ["#6B8E23", "#556B2F", "#808000", "#9ACD32"], // Green variants
  ["#4682B4", "#5F9EA0", "#6495ED", "#87CEEB"], // Blue variants
  ["#9370DB", "#8A2BE2", "#9932CC", "#BA55D3"], // Purple variants
  ["#FF6347", "#FF4500", "#FF7F50", "#FFA07A"], // Red/orange variants
]

// Emoji heads for megapede
const EMOJI_HEADS = [
  "üòé",
  "ü§î",
  "üòÇ",
  "ü•∫",
  "üòç",
  "ü§Ø",
  "üôÑ",
  "üò±",
  "ü§°",
  "üëΩ",
  "ü§ñ",
  "üëæ",
  "ü¶Ñ",
  "üê∏",
  "üçÑ",
  "üíÄ",
  "üî•",
  "üíØ",
  "üçÜ",
  "ü•∂",
  "ü§™",
  "üòà",
  "üëπ",
  "ü§ì",
]

// Metallic colors for armored segments
const METALLIC_COLORS = ["#A9A9A9", "#C0C0C0", "#D3D3D3", "#B8B8B8"]

// Global variables to store the current level's emoji and game level
let CURRENT_LEVEL_EMOJI = "üòé" // Default emoji
let CURRENT_GAME_LEVEL = 1 // Default game level

// Game entities
interface Vector2 {
  x: number
  y: number
}

type Player = {
  position: Vector2
  size: number
  speed: number
  color: string
  energized: boolean
  energyTimer: number
  killCount: number
  energyThreshold: number
  energyDuration: number
}

type Bullet = {
  position: Vector2
  size: number
  speed: number
  active: boolean
}

type Particle = {
  position: Vector2
  velocity: Vector2
  size: number
  color: string
  lifespan: number
  createdAt: number
}

type Mushroom = {
  position: Vector2
  size: number
  health: number
  colorSet: string[] // Array of colors for the egg
  sections: boolean[] // 16 sections (4x4 grid)
}

class MegapedeSegment {
  position: Vector2
  direction: number // +1 = right, -1 = left
  stepSize: number // in pixels (e.g., tile size)
  isHead: boolean
  isAlive = true
  isArmored = false
  armorLevel = 0
  color: string
  emoji = ""
  reachedBottom = false
  size: number // Add size property

  constructor(position: Vector2, direction: number, stepSize: number, isHead: boolean) {
    this.position = position
    this.direction = direction
    this.stepSize = stepSize
    this.isHead = isHead
    this.color = isHead ? "#00FF00" : "#00CC00" // Head is brighter green
    this.size = SEGMENT_SIZE // Initialize with default size
    
    // Emoji will be assigned by the chain constructor based on the level's emoji
  }

  move(gridWidth: number, gridHeight: number, obstacles: Set<string>) {
    if (!this.isHead || !this.isAlive) return

    // Check if reached bottom
    if (this.position.y >= gridHeight - BORDER_WIDTH - this.size * 2) {
      if (!this.reachedBottom) {
        this.reachedBottom = true
        // Reverse vertical direction but keep moving horizontally
        this.position.y = gridHeight - BORDER_WIDTH - this.size * 2 // Ensure it doesn't go below bottom

        // Apply armor to segment but keep the same size
        if (!this.isArmored) {
          this.isArmored = true
          this.armorLevel = 2 // Reduced from 4 to 2 hits to destroy armor
          // Change color when armored
          if (!this.isHead) {
            this.color = METALLIC_COLORS[Math.floor(Math.random() * METALLIC_COLORS.length)]
          }
        }
      }

      // Continue moving horizontally at the bottom
      const nextX = this.position.x + this.direction * this.stepSize
      const hitsBoundary = nextX < BORDER_WIDTH || nextX >= gridWidth - BORDER_WIDTH - this.size

      if (hitsBoundary) {
        this.direction *= -1 // Reverse horizontal direction at boundaries
      } else {
        this.position.x = nextX // Continue moving horizontally
      }

      // Occasionally try to move up if at bottom
      if (Math.random() < 0.05) {
        this.position.y -= this.stepSize // Try to move up
      }
    } else {
      const nextX = this.position.x + this.direction * this.stepSize
      const key = `${Math.floor(nextX / GRID_SIZE)},${Math.floor(this.position.y / GRID_SIZE)}`
      const hitsBoundary = nextX < BORDER_WIDTH || nextX >= gridWidth - BORDER_WIDTH - this.size
      const hitsObstacle = obstacles.has(key)

      if (hitsBoundary || hitsObstacle) {
        this.direction *= -1

        // If reached bottom and going back up, move up instead of down when hitting obstacles
        if (this.reachedBottom) {
          this.position.y -= this.stepSize
        } else {
          this.position.y += this.stepSize
        }
      } else {
        this.position.x = nextX
      }

      // If reached top after being at bottom, reset reachedBottom flag
      if (this.reachedBottom && this.position.y <= BORDER_WIDTH + this.size * 2) {
        this.reachedBottom = false
      }
    }
  }

  takeDamage() {
    if (this.isArmored) {
      this.armorLevel -= 1
      if (this.armorLevel <= 0) {
        // When armor is depleted, immediately destroy the segment
        this.isArmored = false
        this.isAlive = false
        return true // Segment is destroyed
      }
      return false // Armor took the hit, segment still alive
    } else {
      // Unarmored segments die with a single hit
      this.isAlive = false
      return true // Segment is destroyed
    }
  }
}

class MegapedeChain {
  segments: MegapedeSegment[]
  delay: number // time between updates per segment
  stepSize: number
  lastUpdateTime: number

  constructor(length: number, startPos: Vector2, direction: number, stepSize: number) {
    // Adjust step size based on level (slightly smaller steps at level 1)
    this.stepSize = CURRENT_GAME_LEVEL === 1 ? stepSize * 0.7 : stepSize
    this.segments = []
    
    // Adjust delay based on level (longer delay = slower movement at level 1)
    // At level 1: 70ms, level 2: 50ms, level 3+: 30ms
    this.delay = Math.max(30, 90 - (CURRENT_GAME_LEVEL * 20))
    this.lastUpdateTime = Date.now()
    
    // Use the global level emoji instead of accessing gameStateRef
    const levelEmoji = CURRENT_LEVEL_EMOJI

    // Create the segments for the chain
    for (let i = 0; i < length; i++) {
      const isHead = i === 0
      const segmentPos = { ...startPos }

      // If not the head, position behind the previous segment
      if (!isHead) {
        segmentPos.x -= i * stepSize * direction
      }

      const segment = new MegapedeSegment(segmentPos, direction, stepSize, isHead)
      
      // Set the emoji for head segments using the level's emoji
      if (isHead) {
        segment.emoji = levelEmoji
      }
      
      this.segments.push(segment)
    }
  }

  update(gridWidth: number, gridHeight: number, obstacles: Set<string>) {
    // Only update at certain intervals for smoother movement
    const now = Date.now()
    if (now - this.lastUpdateTime < this.delay) return
    this.lastUpdateTime = now

    // Check if segments array is empty
    if (this.segments.length === 0) return

    // Move head
    this.segments[0].move(gridWidth, gridHeight, obstacles)

    // Move body - each segment follows the one in front
    for (let i = this.segments.length - 1; i > 0; i--) {
      if (!this.segments[i].isAlive) continue

      // Store previous position of the segment ahead
      const prevSegment = this.segments[i - 1]

      // Follow the segment ahead
      this.segments[i].position = { ...prevSegment.position }

      // Check if this segment should reach bottom too
      if (this.segments[i].position.y >= gridHeight - BORDER_WIDTH - this.segments[i].size * 2) {
        if (!this.segments[i].reachedBottom) {
          this.segments[i].reachedBottom = true
          if (!this.segments[i].isArmored) {
            this.segments[i].isArmored = true
            this.segments[i].armorLevel = 3 // Reduced from 4 to 3 hits to destroy armor
            if (!this.segments[i].isHead) {
              this.segments[i].color = METALLIC_COLORS[Math.floor(Math.random() * METALLIC_COLORS.length)]
            }
          }
        }
      }
    }
  }

  // Create a new chain from segments starting at index
  createNewChainFromSegments(index: number): MegapedeChain | null {
    if (index <= 0 || index >= this.segments.length) return null

    // Get segments for the new chain
    const newSegments = this.segments.slice(index)

    // Remove these segments from the current chain
    this.segments = this.segments.slice(0, index)

    // If no segments left in either chain, return null
    if (newSegments.length === 0) return null
    if (this.segments.length === 0) return null

    // Make the first segment of the new chain the head
    newSegments[0].isHead = true
    // Assign the current level emoji to the new head using the global variable
    newSegments[0].emoji = CURRENT_LEVEL_EMOJI
    // Reverse direction for the new chain
    newSegments[0].direction *= -1

    // Create a new chain with these segments
    // Create a new chain with these segments
    // The speed will be controlled by the global CURRENT_GAME_LEVEL variable
    const newChain = new MegapedeChain(0, { x: 0, y: 0 }, newSegments[0].direction, this.stepSize)
    newChain.segments = newSegments

    return newChain
  }

  splitAt(index: number): MegapedeChain[] {
    if (index <= 0 || index >= this.segments.length) return [this]

    const leftSegments = this.segments.slice(0, index)
    const rightSegments = this.segments.slice(index + 1)

    // Make the first segment of the right chain the new head
    if (rightSegments.length > 0) {
      rightSegments[0].isHead = true
      // Assign the current level emoji to the new head using the global variable
      rightSegments[0].emoji = CURRENT_LEVEL_EMOJI
    }

    // Create new chains from the segments
    const chains: MegapedeChain[] = []

    if (leftSegments.length > 0) {
      const leftChain = new MegapedeChain(0, { x: 0, y: 0 }, 1, this.stepSize)
      leftChain.segments = leftSegments
      // Carry over the delay from the parent chain to maintain speed consistency
      leftChain.delay = this.delay
      chains.push(leftChain)
    }

    if (rightSegments.length > 0) {
      const rightChain = new MegapedeChain(0, { x: 0, y: 0 }, 1, this.stepSize)
      rightChain.segments = rightSegments
      // Carry over the delay from the parent chain to maintain speed consistency
      rightChain.delay = this.delay
      rightChain.segments = rightSegments
      chains.push(rightChain)
    }

    return chains
  }
}

class Spider {
  position: Vector2
  direction: Vector2
  speed: number
  size: number
  isAlive = true
  color = "#FF0000" // Red color for spiders
  targetBlock: Vector2 | null = null
  targetSection: number | null = null
  targetSections: number[] = [] // Multiple sections to chew
  chewingTime = 0
  chewingDuration = 500 // Time to chew through a section in ms
  isChewing = false
  lastDirectionChange = 0
  directionChangeDelay = 1000 // ms between direction changes
  chaseSpeed = 0.5 // Slower speed when chasing upward
  isAtBottom = false // Flag to track if spider is at the bottom
  aggressiveChaseSpeed = 1.5 // Faster speed when aggressively chasing

  constructor(position: Vector2, speed: number, size: number) {
    this.position = position
    this.direction = { x: Math.random() > 0.5 ? 1 : -1, y: 0 } // Start moving horizontally
    this.speed = speed
    this.size = size
    this.lastDirectionChange = Date.now()
  }

  update(bounds: Vector2, obstacles: Set<string>, mushrooms: Mushroom[], playerPosition: Vector2) {
    // If currently chewing a block
    if (this.isChewing && this.targetBlock && this.targetSections.length > 0) {
      this.chewingTime += 16 // Assuming ~60fps

      // If finished chewing
      if (this.chewingTime >= this.chewingDuration) {
        this.isChewing = false
        this.chewingTime = 0

        // Find the mushroom we're chewing
        const mushroom = mushrooms.find(
          (m) => m.position.x === this.targetBlock!.x && m.position.y === this.targetBlock!.y,
        )

        // Destroy the sections we're chewing (up to 2 at a time)
        if (mushroom) {
          for (const sectionIndex of this.targetSections) {
            if (sectionIndex >= 0 && sectionIndex < 16 && mushroom.sections[sectionIndex]) {
              mushroom.sections[sectionIndex] = false
              mushroom.health--
            }
          }
        }

        this.targetBlock = null
        this.targetSections = []

        // Continue moving down
        this.direction = { x: 0, y: 1 }
      }
      return
    }

    // Check if there's a block below, above, or to the sides
    const blockInfo = this.findBlockInPath(mushrooms)

    if (blockInfo) {
      // Start chewing the block or change direction
      if (this.direction.y > 0 && blockInfo.direction === "below") {
        // If moving down and block is below, start chewing
        this.isChewing = true
        this.targetBlock = { x: blockInfo.mushroom.position.x, y: blockInfo.mushroom.position.y }

        // Find a second adjacent section to chew if possible
        this.targetSections = [blockInfo.sectionIndex]

        // Try to find an adjacent section that's also active
        const row = Math.floor(blockInfo.sectionIndex / 4)
        const col = blockInfo.sectionIndex % 4

        // Check right
        if (col < 3 && blockInfo.mushroom.sections[row * 4 + col + 1]) {
          this.targetSections.push(row * 4 + col + 1)
        }
        // Check left
        else if (col > 0 && blockInfo.mushroom.sections[row * 4 + col - 1]) {
          this.targetSections.push(row * 4 + col - 1)
        }
        // Check below
        else if (row < 3 && blockInfo.mushroom.sections[(row + 1) * 4 + col]) {
          this.targetSections.push((row + 1) * 4 + col)
        }
        // Check above
        else if (row > 0 && blockInfo.mushroom.sections[(row - 1) * 4 + col]) {
          this.targetSections.push((row - 1) * 4 + col)
        }

        return
      } else {
        // If block is in other directions, change direction
        if (blockInfo.direction === "above") {
          this.direction = { x: Math.random() > 0.5 ? 1 : -1, y: 0 }
        } else if (blockInfo.direction === "left") {
          this.direction = { x: 1, y: Math.random() > 0.5 ? -1 : 1 }
        } else if (blockInfo.direction === "right") {
          this.direction = { x: -1, y: Math.random() > 0.5 ? -1 : 1 }
        }
        this.lastDirectionChange = Date.now()
        return
      }
    }

    const now = Date.now()

    // Check if spider is at the bottom of the screen
    this.isAtBottom = this.position.y >= bounds.y - BORDER_WIDTH - this.size - 10

    // More aggressive chasing when at the bottom
    if (this.isAtBottom) {
      // Calculate direction to player
      const dirToPlayer = {
        x: playerPosition.x - this.position.x,
        y: playerPosition.y - this.position.y,
      }

      // Normalize direction
      const length = Math.sqrt(dirToPlayer.x * dirToPlayer.x + dirToPlayer.y * dirToPlayer.y)
      if (length > 0) {
        dirToPlayer.x /= length
        dirToPlayer.y /= length
      }

      // Set direction toward player with higher probability
      if (Math.random() < 0.3 || now - this.lastDirectionChange > this.directionChangeDelay) {
        this.direction = {
          x: dirToPlayer.x,
          y: dirToPlayer.y < 0 ? -1 : 0, // Only go up or horizontal
        }
        this.lastDirectionChange = now
      }
    }
    // Normal behavior when not at bottom
    else {
      // Check if player is above the spider and we should chase
      const playerAbove =
        playerPosition.y < this.position.y &&
        playerPosition.x > this.position.x - this.size * 2 &&
        playerPosition.x < this.position.x + this.size * 2

      // Occasionally change direction to chase player if they're above
      if (playerAbove && now - this.lastDirectionChange > this.directionChangeDelay && Math.random() < 0.1) {
        // Move upward to chase player
        this.direction = {
          x: playerPosition.x > this.position.x ? 0.5 : -0.5,
          y: -1,
        }
        this.lastDirectionChange = now
      }
      // Randomly change direction occasionally
      else if (now - this.lastDirectionChange > this.directionChangeDelay && Math.random() < 0.05) {
        if (this.direction.y === 0) {
          // If moving horizontally, sometimes start moving down
          this.direction = { x: 0, y: 1 }
        } else if (this.direction.y > 0) {
          // If moving down, sometimes start moving horizontally
          this.direction = { x: Math.random() > 0.5 ? 1 : -1, y: 0 }
        } else {
          // If moving up, sometimes start moving horizontally
          this.direction = { x: Math.random() > 0.5 ? 1 : -1, y: 0 }
        }
        this.lastDirectionChange = now
      }
    }

    // Store previous position for collision detection
    const prevPosition = { ...this.position }

    // Normal movement if not chewing
    const actualSpeed = this.isAtBottom
      ? this.aggressiveChaseSpeed
      : this.direction.y < 0
        ? this.chaseSpeed
        : this.speed // Slower when moving up, faster when aggressive

    this.position.x += this.direction.x * actualSpeed
    this.position.y += this.direction.y * actualSpeed

    // Enforce boundaries - keep spiders inside the play area
    if (this.position.x < BORDER_WIDTH) {
      this.position.x = BORDER_WIDTH
      this.direction.x *= -1
    } else if (this.position.x > bounds.x - BORDER_WIDTH - this.size) {
      this.position.x = bounds.x - BORDER_WIDTH - this.size
      this.direction.x *= -1
    }

    // If hit bottom, stay at bottom and move horizontally
    if (this.position.y >= bounds.y - BORDER_WIDTH - this.size) {
      this.position.y = bounds.y - BORDER_WIDTH - this.size
      if (this.direction.y > 0) {
        this.direction = { x: Math.random() > 0.5 ? 1 : -1, y: 0 }
      }
    }

    // If hit top, start moving horizontally or down
    if (this.position.y <= BORDER_WIDTH) {
      this.position.y = BORDER_WIDTH
      this.direction = { x: Math.random() > 0.5 ? 1 : -1, y: Math.random() > 0.7 ? 0 : 1 }
    }

    // Check for collisions with mushrooms after moving
    for (let i = 0; i < mushrooms.length; i++) {
      const mushroom = mushrooms[i]
      const collision = this.checkCollisionWithMushroom(mushroom)
      
      if (collision.collided) {
        if (collision.destroyed) {
          // Destroy a random section of the mushroom
          let activeSections = []
          for (let j = 0; j < mushroom.sections.length; j++) {
            if (mushroom.sections[j]) {
              activeSections.push(j)
            }
          }
          
          // If there are active sections, destroy one
          if (activeSections.length > 0) {
            const sectionToDestroy = activeSections[Math.floor(Math.random() * activeSections.length)]
            mushroom.sections[sectionToDestroy] = false
            
            // Continue moving - the spider "ate" through this part
            continue
          }
        }
        
        // If we didn't destroy a section or there are none left, revert position and change direction
        this.position = prevPosition

        // Change direction based on where we hit the mushroom
        if (this.direction.x > 0) {
          // Moving right, hit left side of mushroom
          this.direction = { x: -1, y: Math.random() > 0.5 ? 0 : -1 }
        } else if (this.direction.x < 0) {
          // Moving left, hit right side of mushroom
          this.direction = { x: 1, y: Math.random() > 0.5 ? 0 : -1 }
        } else if (this.direction.y > 0) {
          // Moving down, hit top of mushroom
          this.direction = { x: Math.random() > 0.5 ? 1 : -1, y: -1 }
        } else if (this.direction.y < 0) {
          // Moving up, hit bottom of mushroom
          this.direction = { x: Math.random() > 0.5 ? 1 : -1, y: 1 }
        }

        this.lastDirectionChange = Date.now()
        break
      }
    }
  }

  checkCollisionWithMushroom(mushroom: Mushroom): { collided: boolean; destroyed: boolean } {
    // Check if any part of the spider collides with any section of the mushroom
    const spiderRight = this.position.x + this.size
    const spiderBottom = this.position.y + this.size
    const mushroomRight = mushroom.position.x + mushroom.size
    const mushroomBottom = mushroom.position.y + mushroom.size

    if (
      this.position.x < mushroomRight &&
      spiderRight > mushroom.position.x &&
      this.position.y < mushroomBottom &&
      spiderBottom > mushroom.position.y
    ) {
      // Determine if the spider should destroy a section of the mushroom
      // Higher chance to destroy if the spider is aggressive (at bottom of screen)
      const destroyChance = this.isAtBottom ? 0.6 : 0.3
      const shouldDestroy = Math.random() < destroyChance

      return { collided: true, destroyed: shouldDestroy }
    }
    return { collided: false, destroyed: false }
  }

  findBlockInPath(mushrooms: Mushroom[]): { mushroom: Mushroom; sectionIndex: number; direction: string } | null {
    // Check for blocks in the direction we're moving
    for (const mushroom of mushrooms) {
      // Check each section of the mushroom
      for (let i = 0; i < 16; i++) {
        if (!mushroom.sections[i]) continue

        const sectionX = mushroom.position.x + (i % 4) * SECTION_SIZE
        const sectionY = mushroom.position.y + Math.floor(i / 4) * SECTION_SIZE

        // Check below (if moving down)
        if (
          this.direction.y > 0 &&
          this.position.x < sectionX + SECTION_SIZE &&
          this.position.x + this.size > sectionX &&
          this.position.y + this.size <= sectionY &&
          this.position.y + this.size + this.speed >= sectionY
        ) {
          return { mushroom, sectionIndex: i, direction: "below" }
        }

        // Check above (if moving up)
        if (
          this.direction.y < 0 &&
          this.position.x < sectionX + SECTION_SIZE &&
          this.position.x + this.size > sectionX &&
          this.position.y >= sectionY + SECTION_SIZE &&
          this.position.y - this.speed <= sectionY + SECTION_SIZE
        ) {
          return { mushroom, sectionIndex: i, direction: "above" }
        }

        // Check left (if moving left)
        if (
          this.direction.x < 0 &&
          this.position.y < sectionY + SECTION_SIZE &&
          this.position.y + this.size > sectionY &&
          this.position.x >= sectionX + SECTION_SIZE &&
          this.position.x - this.speed <= sectionX + SECTION_SIZE
        ) {
          return { mushroom, sectionIndex: i, direction: "left" }
        }

        // Check right (if moving right)
        if (
          this.direction.x > 0 &&
          this.position.y < sectionY + SECTION_SIZE &&
          this.position.y + this.size > sectionY &&
          this.position.x + this.size <= sectionX &&
          this.position.x + this.size + this.speed >= sectionX
        ) {
          return { mushroom, sectionIndex: i, direction: "right" }
        }
      }
    }
    return null;
  }
}

export default function MegapedeGame() {
  const canvasRef = useRef<HTMLCanvasElement | null>(null)
  const gameContainerRef = useRef<HTMLDivElement | null>(null)
  const [gameStarted, setGameStarted] = useState(false)
  const [gameOver, setGameOver] = useState(false)
  const [score, setScore] = useState(0)
  const [level, setLevel] = useState(1)
  const [isFullscreen, setIsFullscreen] = useState(false)
  const [canvasSize, setCanvasSize] = useState({ width: GAME_WIDTH, height: GAME_HEIGHT })

  // Game state refs to avoid dependency issues in the game loop
  const gameStateRef = useRef({
    player: {
      position: { x: GAME_WIDTH / 2, y: GAME_HEIGHT - PLAYER_SIZE * 2 },
      size: PLAYER_SIZE,
      speed: PLAYER_SPEED,
      color: "#FF0000",
      energized: false,
      energyTimer: 0,
      killCount: 0,
      energyThreshold: 10,
      energyDuration: 5000,
    } as Player,
    bullets: [] as Bullet[],
    megapedeChains: [] as MegapedeChain[],
    spiders: [] as Spider[],
    mushrooms: [] as Mushroom[],
    particles: [] as Particle[],
    obstacleGrid: new Set<string>(),
    keys: {
      left: false,
      right: false,
      up: false,
      down: false,
      space: false,
    },
    lastShootTime: 0,
    lastUpdateTime: 0, // Adding the missing property
    lastSpiderSpawnTime: 0,
    spiderSpawnRate: 10000, // ms between spider spawns
    lastMushroomSpawnTime: 0,
    mushroomSpawnRate: 3000, // ms between mushroom spawns
    score: 0,
    level: 1,
    gameOver: false,
    levelEmoji: "" // Store consistent emoji for each level
  })

  // Create particles when mushroom is hit
  const createMushroomParticles = (position: Vector2, sectionIndex: number, colorSet: string[]) => {
    const state = gameStateRef.current

    // Calculate section position
    const sectionX = position.x + (sectionIndex % 4) * SECTION_SIZE
    const sectionY = position.y + Math.floor(sectionIndex / 4) * SECTION_SIZE

    // Create particles
    for (let i = 0; i < PARTICLE_COUNT; i++) {
      const angle = Math.random() * Math.PI * 2
      const speed = 1 + Math.random() * 2
      // Use a random color from the mushroom's color set
      const color = colorSet[Math.floor(Math.random() * colorSet.length)]

      state.particles.push({
        position: { x: sectionX + SECTION_SIZE / 2, y: sectionY + SECTION_SIZE / 2 },
        velocity: { x: Math.cos(angle) * speed, y: Math.sin(angle) * speed },
        size: PARTICLE_SIZE,
        color,
        lifespan: 1000, // 1 second
        createdAt: Date.now(),
      })
    }
  }

  // Create a new mushroom
  const createMushroom = (x: number, y: number) => {
    const state = gameStateRef.current

    // Align to grid
    const gridX = Math.floor(x / GRID_SIZE) * GRID_SIZE
    const gridY = Math.floor(y / GRID_SIZE) * GRID_SIZE

    // Select a random color set for this egg
    const colorSet = EGG_COLORS[Math.floor(Math.random() * EGG_COLORS.length)]

    const mushroom: Mushroom = {
      position: { x: gridX, y: gridY },
      size: MUSHROOM_SIZE,
      health: 16, // 16 sections (4x4 grid)
      colorSet, // Assign the color set
      sections: Array(16).fill(true), // All 16 sections intact
    }

    state.mushrooms.push(mushroom)

    // Add to obstacle grid
    const key = `${Math.floor(gridX / GRID_SIZE)},${Math.floor(gridY / GRID_SIZE)}`
    state.obstacleGrid.add(key)

    return mushroom
  }

  // Initialize game
  const initGame = () => {
    setGameStarted(true)
    setGameOver(false)

    // Reset game state
    const state = gameStateRef.current
    state.player = {
      position: {
        x: GAME_WIDTH / 2 - PLAYER_SIZE / 2,
        y: GAME_HEIGHT - PLAYER_SIZE * 2,
      },
      size: PLAYER_SIZE,
      speed: PLAYER_SPEED,
      color: "#00FFFF", // Cyan
      energized: false,
      energyTimer: 0,
      killCount: 0,
      energyThreshold: 10, // Number of kills needed to get energy
      energyDuration: 5000, // Duration of energized state in ms
    }
    state.bullets = []
    state.mushrooms = []
    state.particles = []
    state.megapedeChains = []
    state.spiders = []
    state.obstacleGrid = new Set()
    state.score = 0
    state.level = 1
    state.lastUpdateTime = Date.now()
    state.lastSpiderSpawnTime = Date.now()
    
    // Choose a random emoji for this level's megapede and update global variables
    state.levelEmoji = EMOJI_HEADS[Math.floor(Math.random() * EMOJI_HEADS.length)]
    CURRENT_LEVEL_EMOJI = state.levelEmoji // Update the global emoji variable
    CURRENT_GAME_LEVEL = state.level     // Update the global level variable

    // Significantly more mushrooms
    const mushroomCount = 80 + state.level * 10 // Increased from 30 to 80

    // Create mushrooms in the top half of the screen
    for (let i = 0; i < mushroomCount * 0.6; i++) {
      const mushroomX = Math.floor(Math.random() * (GAME_WIDTH - MUSHROOM_SIZE * 2 - BORDER_WIDTH * 2) + BORDER_WIDTH)
      const mushroomY = Math.floor(Math.random() * (GAME_HEIGHT / 2 - MUSHROOM_SIZE * 2) + BORDER_WIDTH)
      createMushroom(mushroomX, mushroomY)
    }

    // Create mushrooms in the player's area (bottom half)
    for (let i = 0; i < mushroomCount * 0.4; i++) {
      const mushroomX = Math.floor(Math.random() * (GAME_WIDTH - MUSHROOM_SIZE * 2 - BORDER_WIDTH * 2) + BORDER_WIDTH)
      const mushroomY = Math.floor(Math.random() * (GAME_HEIGHT / 2) + GAME_HEIGHT / 2)
      createMushroom(mushroomX, mushroomY)
    }

    // Create megapede chain
    const segmentCount = 12 + state.level * 2
    const startX = Math.random() > 0.5 ? BORDER_WIDTH : GAME_WIDTH - BORDER_WIDTH - SEGMENT_SIZE
    const direction = startX === BORDER_WIDTH ? 1 : -1
    const startY = SEGMENT_SIZE + BORDER_WIDTH

    // The megapede constructor will use the global CURRENT_GAME_LEVEL variable
    const megapedeChain = new MegapedeChain(segmentCount, { x: startX, y: startY }, direction, SEGMENT_SIZE)

    state.megapedeChains.push(megapedeChain)

    // Reset timers
    state.lastSpiderSpawnTime = Date.now()

    state.score = score
    state.level = level
    CURRENT_GAME_LEVEL = level // Update global level variable
    state.gameOver = false

    setGameStarted(true)
    setGameOver(false)
  }

  // Handle keyboard input
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      const state = gameStateRef.current

      switch (e.key) {
        case "ArrowLeft":
          state.keys.left = true
          break
        case "ArrowRight":
          state.keys.right = true
          break
        case "ArrowUp":
          state.keys.up = true
          break
        case "ArrowDown":
          state.keys.down = true
          break
        case " ":
          state.keys.space = true
          break
      }
    }

    const handleKeyUp = (e: KeyboardEvent) => {
      const state = gameStateRef.current

      switch (e.key) {
        case "ArrowLeft":
          state.keys.left = false
          break
        case "ArrowRight":
          state.keys.right = false
          break
        case "ArrowUp":
          state.keys.up = false
          break
        case "ArrowDown":
          state.keys.down = false
          break
        case " ":
          state.keys.space = false
          break
      }
    }

    window.addEventListener("keydown", handleKeyDown)
  }

  setCanvasSize({ width: newWidth, height: newHeight })
        {/* Fullscreen toggle button */}
        {gameStarted && (
          <Button 
            onClick={toggleFullscreen}
            className="absolute top-2 right-2 bg-blue-800 hover:bg-blue-900 text-xs py-1 px-2 opacity-70 hover:opacity-100 transition-opacity"
            aria-label={isFullscreen ? "Exit fullscreen" : "Enter fullscreen"}
          >
            {isFullscreen ? "Exit Fullscreen" : "Fullscreen"}
          </Button>
        )}

        {!gameStarted && (
          <div className="absolute inset-0 flex flex-col items-center justify-center bg-black bg-opacity-80">
            <h2 className="text-2xl font-bold text-white mb-4">{gameOver ? "GAME OVER" : "MEGAPEDE"}</h2>
            {gameOver && <p className="text-white mb-4">Score: {score}</p>}
            <Button onClick={handleStartGame} className="bg-blue-600 hover:bg-blue-700 mb-2">
              {gameOver ? "Play Again" : "Start Game"}
            </Button>
            <Button 
              onClick={toggleFullscreen}
              className="bg-blue-800 hover:bg-blue-900 text-xs mt-2"
            >
              {isFullscreen ? "Exit Fullscreen" : "Fullscreen Mode"}
            </Button>
          </div>
        )}
      </div>

      <div className="mt-4 text-white text-center">
        <p>Use arrow keys to move and spacebar to shoot</p>
        <p>Destroy the megapede before it reaches you!</p>
        <p>Fly into blocks to clear them from your path!</p>
      </div>
    </div>
  )
}

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Megapede - Portable 404 Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background: #000;
            color: white;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        #gameContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: #000;
        }

        #gameCanvas {
            background: #000;
            border: 2px solid #4D88FF;
            max-width: 90vw;
            max-height: 70vh;
        }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        .hidden {
            display: none;
        }

        button {
            background: #4D88FF;
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.3s;
        }

        button:hover {
            background: #3366CC;
        }

        .controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 5;
        }

        .mobile-controls {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 200px;
            background: rgba(40, 40, 40, 0.9);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            z-index: 5;
        }

        .dpad {
            position: relative;
            width: 120px;
            height: 120px;
        }

        .dpad-button {
            position: absolute;
            width: 40px;
            height: 40px;
            background: #666;
            border: none;
            color: white;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            user-select: none;
            transition: background 0.1s;
        }

        .dpad-button:active {
            background: #888;
        }

        .dpad-up {
            top: 0;
            left: 40px;
            border-radius: 8px 8px 0 0;
        }

        .dpad-down {
            bottom: 0;
            left: 40px;
            border-radius: 0 0 8px 8px;
        }

        .dpad-left {
            left: 0;
            top: 40px;
            border-radius: 8px 0 0 8px;
        }

        .dpad-right {
            right: 0;
            top: 40px;
            border-radius: 0 8px 8px 0;
        }

        .shoot-button {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: #FF4444;
            border: none;
            color: white;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.1s;
        }

        .shoot-button:active {
            background: #FF6666;
        }

        .energy-indicator {
            position: fixed;
            top: 10px;
            right: 10px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #666;
            z-index: 5;
            transition: background 0.3s;
        }

        .energy-ready {
            background: #FFD700;
        }

        .plasma-active {
            background: #00AAFF;
        }

        @media (max-width: 768px) {
            .controls {
                display: none;
            }
        }

        @media (min-width: 769px) {
            .mobile-controls {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        
        <!-- Energy Indicator -->
        <div id="energyIndicator" class="energy-indicator"></div>
        
        <!-- Start Screen -->
        <div id="startScreen" class="overlay">
            <h1 style="font-size: 48px; margin-bottom: 20px; color: #4D88FF;">Megapede</h1>
            <p style="font-size: 18px; margin-bottom: 30px; text-align: center; max-width: 600px;">
                Defend against the alien megapede invasion! Use arrow keys to move and spacebar to shoot.<br>
                Destroy the megapede before it reaches the bottom!
            </p>
            <button onclick="startGame()">Start Game</button>
        </div>
        
        <!-- Game Over Screen -->
        <div id="gameOverScreen" class="overlay hidden">
            <h1 style="font-size: 48px; margin-bottom: 20px; color: #FF4444;">Game Over</h1>
            <p id="finalScore" style="font-size: 24px; margin-bottom: 30px;"></p>
            <button onclick="startGame()">Play Again</button>
        </div>
        
        <!-- Desktop Controls -->
        <div class="controls">
            <div style="font-size: 14px; text-align: center;">
                Arrow Keys: Move | Spacebar: Shoot
            </div>
        </div>
        
        <!-- Mobile Controls -->
        <div class="mobile-controls">
            <div class="dpad">
                <button class="dpad-button dpad-up" onmousedown="handleInput('up', true)" onmouseup="handleInput('up', false)" ontouchstart="handleInput('up', true)" ontouchend="handleInput('up', false)">‚Üë</button>
                <button class="dpad-button dpad-down" onmousedown="handleInput('down', true)" onmouseup="handleInput('down', false)" ontouchstart="handleInput('down', true)" ontouchend="handleInput('down', false)">‚Üì</button>
                <button class="dpad-button dpad-left" onmousedown="handleInput('left', true)" onmouseup="handleInput('left', false)" ontouchstart="handleInput('left', true)" ontouchend="handleInput('left', false)">‚Üê</button>
                <button class="dpad-button dpad-right" onmousedown="handleInput('right', true)" onmouseup="handleInput('right', false)" ontouchstart="handleInput('right', true)" ontouchend="handleInput('right', false)">‚Üí</button>
            </div>
            <button class="shoot-button" onmousedown="handleInput('shoot', true)" onmouseup="handleInput('shoot', false)" ontouchstart="handleInput('shoot', true)" ontouchend="handleInput('shoot', false)">FIRE</button>
        </div>
    </div>

    <script>
        // Game constants
        const BASE_GAME_WIDTH = 800;
        const BASE_GAME_HEIGHT = 600;
        let GAME_WIDTH = BASE_GAME_WIDTH;
        let GAME_HEIGHT = BASE_GAME_HEIGHT;
        let SCALE_FACTOR = 1;

        const BORDER_WIDTH = 1;
        const BOTTOM_BORDER_WIDTH = 40;
        const PLAYER_SIZE = 40;
        const PLAYER_SPEED = 5;
        const BULLET_SIZE = 5;
        const BULLET_SPEED = 10;
        const SHOOT_COOLDOWN = 200;
        const SEGMENT_SIZE = 20;
        const MUSHROOM_SIZE = 20;
        const SECTION_SIZE = MUSHROOM_SIZE / 4;
        const SPIDER_SIZE = 20;
        const PARTICLE_COUNT = 8;

        const BASE_MEGAPEDE_SPEED = 1.0;
        const BASE_SPIDER_SPEED = 0.8;
        const SPEED_INCREASE_PER_LEVEL = 0.1;
        const BASE_SEGMENT_COUNT = 20;
        const SEGMENTS_INCREASE_LEVEL = 3;

        const GLOW_COLOR = "rgba(0, 255, 255, 0.7)";
        const PLAYER_GLOW_RADIUS = 45;
        const BULLET_GLOW_RADIUS = 10;
        const EXPLOSION_COLORS = ["#FF5E5E", "#FFD700", "#FF8C00", "#FFA07A", "#FFFF00"];
        const BG_GRADIENT_COLORS = ["#000033", "#000066", "#000033"];
        const GRID_SIZE = SEGMENT_SIZE;
        const PARTICLE_SIZE = 1.5;
        const BASIC_PARTICLE_COUNT = 4;
        const BULLET_RADIUS = 6;
        const MUSHROOM_FALL_CHANCE = 0.01;
        const MUSHROOM_FALL_SPEED = 1;

        const EGG_COLORS = [
            ["#8B4513", "#A52A2A", "#CD853F", "#D2691E"],
            ["#6B8E23", "#556B2F", "#808000", "#9ACD32"],
            ["#4682B4", "#5F9EA0", "#6495ED", "#87CEEB"],
            ["#9370DB", "#8A2BE2", "#9932CC", "#BA55D3"],
            ["#FF6347", "#FF4500", "#FF7F50", "#FFA07A"],
        ];

        const EMOJI_HEADS = ["üëπ"];
        const METALLIC_COLORS = ["#A9A9A9", "#C0C0C0", "#D3D3D3", "#B8B8B8"];

        let CURRENT_LEVEL_EMOJI = "üëπ";
        let CURRENT_GAME_LEVEL = 1;

        // Game state
        let gameState = {
            gameStarted: false,
            gameOver: false,
            score: 0,
            level: 1,
            player: {
                position: { x: GAME_WIDTH / 2, y: GAME_HEIGHT - PLAYER_SIZE * 2 },
                size: PLAYER_SIZE,
                speed: PLAYER_SPEED,
                color: "#00FFFF",
                energized: false,
                energyTimer: 0,
                killCount: 0,
                energyThreshold: 10,
                energyDuration: 5000,
                plasmaAmmo: 0,
                plasmaActive: false,
                plasmaTimer: 0,
                plasmaDuration: 5000,
            },
            bullets: [],
            megapedeChains: [],
            spiders: [],
            mushrooms: [],
            particles: [],
            powerUps: [],
            obstacleGrid: new Set(),
            keys: {
                left: false,
                right: false,
                up: false,
                down: false,
                space: false,
            },
            autoShootEnabled: false,
            lastShootTime: 0,
            lastUpdateTime: 0,
            lastSpiderSpawnTime: 0,
            spiderSpawnRate: 10000,
            lastPowerUpSpawnTime: 0,
            powerUpSpawnRate: 45000,
            lastMushroomSpawnTime: 0,
            mushroomSpawnRate: 3000,
            levelEmoji: "",
        };

        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let animationId;

        // Input handling
        const keys = {};

        function handleInput(action, pressed) {
            if (action === 'shoot' && pressed) {
                gameState.autoShootEnabled = !gameState.autoShootEnabled;
            } else {
                gameState.keys[action] = pressed;
            }
        }

        // Keyboard event listeners
        document.addEventListener('keydown', (e) => {
            switch (e.key) {
                case 'ArrowLeft':
                    gameState.keys.left = true;
                    break;
                case 'ArrowRight':
                    gameState.keys.right = true;
                    break;
                case 'ArrowUp':
                    gameState.keys.up = true;
                    break;
                case 'ArrowDown':
                    gameState.keys.down = true;
                    break;
                case ' ':
                    gameState.keys.space = true;
                    e.preventDefault();
                    break;
            }
        });

        document.addEventListener('keyup', (e) => {
            switch (e.key) {
                case 'ArrowLeft':
                    gameState.keys.left = false;
                    break;
                case 'ArrowRight':
                    gameState.keys.right = false;
                    break;
                case 'ArrowUp':
                    gameState.keys.up = false;
                    break;
                case 'ArrowDown':
                    gameState.keys.down = false;
                    break;
                case ' ':
                    gameState.keys.space = false;
                    break;
            }
        });

        // Megapede Segment Class
        class MegapedeSegment {
            constructor(position, direction, stepSize, isHead) {
                this.position = position;
                this.direction = direction;
                this.stepSize = stepSize;
                this.isHead = isHead;
                this.isAlive = true;
                this.isArmored = false;
                this.armorLevel = 0;
                this.color = isHead ? "#00FF00" : "#00CC00";
                this.emoji = "";
                this.reachedBottom = false;
                this.size = SEGMENT_SIZE;
                this.armorLevel = isHead ? 3 : 0;
            }

            move(gridWidth, gridHeight, obstacles) {
                if (!this.isHead || !this.isAlive) return;

                if (this.position.y >= gridHeight - BOTTOM_BORDER_WIDTH - this.size * 2) {
                    if (!this.reachedBottom) {
                        this.reachedBottom = true;
                        this.isArmored = true;
                        this.armorLevel = 6;
                    }
                    this.position.y = gridHeight - BOTTOM_BORDER_WIDTH - this.size * 2;

                    const nextX = this.position.x + this.direction * this.stepSize;
                    const hitsBoundary = nextX < BORDER_WIDTH || nextX >= gridWidth - BORDER_WIDTH - this.size;

                    if (hitsBoundary) {
                        this.direction *= -1;
                    } else {
                        this.position.x = nextX;
                    }

                    if (Math.random() < 0.05) {
                        this.position.y -= this.stepSize;
                    }
                } else {
                    const nextX = this.position.x + this.direction * this.stepSize;
                    const key = `${Math.floor(nextX / GRID_SIZE)},${Math.floor(this.position.y / GRID_SIZE)}`;
                    const hitsBoundary = nextX < BORDER_WIDTH || nextX >= gridWidth - BORDER_WIDTH - this.size;
                    const hitsObstacle = obstacles.has(key);

                    if (hitsBoundary || hitsObstacle) {
                        this.direction *= -1;
                        if (this.reachedBottom) {
                            this.position.y -= this.stepSize;
                        } else {
                            this.position.y += this.stepSize;
                        }
                    } else {
                        this.position.x = nextX;
                    }

                    if (this.reachedBottom && this.position.y <= BORDER_WIDTH + this.size * 2) {
                        this.reachedBottom = false;
                        if (this.isArmored && this.armorLevel <= 6) {
                            this.isArmored = false;
                            this.armorLevel = 0;
                        }
                    }
                }
            }

            takeDamage() {
                if (this.isArmored) {
                    this.armorLevel -= 1;
                    if (this.armorLevel <= 0) {
                        this.isArmored = false;
                        this.isAlive = false;
                        return true;
                    }
                    return false;
                } else {
                    this.isAlive = false;
                    return true;
                }
            }
        }

        // Megapede Chain Class
        class MegapedeChain {
            constructor(segmentCount, startPosition, direction, segmentSize, speed = BASE_MEGAPEDE_SPEED) {
                const level = CURRENT_GAME_LEVEL || 1;
                speed = BASE_MEGAPEDE_SPEED + (level - 1) * SPEED_INCREASE_PER_LEVEL;
                this.stepSize = CURRENT_GAME_LEVEL === 1 ? segmentSize * 0.7 : segmentSize;
                this.segments = [];
                this.delay = Math.max(30, 90 - (level - 1) * 20);
                this.lastUpdateTime = Date.now();
                
                const levelEmoji = CURRENT_LEVEL_EMOJI;

                for (let i = 0; i < segmentCount; i++) {
                    const isHead = i === 0;
                    const segmentPos = { ...startPosition };

                    if (!isHead) {
                        segmentPos.x -= i * segmentSize * direction;
                    }

                    const segment = new MegapedeSegment(segmentPos, direction, segmentSize, isHead);
                    
                    if (isHead) {
                        segment.emoji = levelEmoji;
                    }
                    
                    this.segments.push(segment);
                }
            }

            update(gridWidth, gridHeight, obstacles) {
                const now = Date.now();
                if (now - this.lastUpdateTime < this.delay) return;
                this.lastUpdateTime = now;

                if (this.segments.length === 0) return;

                this.segments[0].move(gridWidth, gridHeight, obstacles);

                for (let i = this.segments.length - 1; i > 0; i--) {
                    if (!this.segments[i].isAlive) continue;

                    const prevSegment = this.segments[i - 1];
                    this.segments[i].position = { ...prevSegment.position };

                    for (let j = 0; j < this.segments.length; j++) {
                        if (this.segments[j].position.y >= gridHeight - BOTTOM_BORDER_WIDTH - SEGMENT_SIZE * 2) {
                            for (let k = 0; k < this.segments.length; k++) {
                                if (!this.segments[k].isArmored) {
                                    this.segments[k].isArmored = true;
                                    this.segments[k].armorLevel = this.segments[k].isHead ? 5 : 7;
                                    if (!this.segments[k].isHead) {
                                        this.segments[k].color = METALLIC_COLORS[Math.floor(Math.random() * METALLIC_COLORS.length)];
                                    }
                                }
                            }
                        }
                    }
                }
            }

            createNewChainFromSegments(index) {
                if (index <= 0 || index >= this.segments.length) return null;

                const newSegments = this.segments.slice(index);
                this.segments = this.segments.slice(0, index);

                if (newSegments.length === 0) return null;
                if (this.segments.length === 0) return null;

                newSegments[0].isHead = true;
                newSegments[0].emoji = CURRENT_LEVEL_EMOJI;
                newSegments[0].direction *= -1;

                const newChain = new MegapedeChain(0, { x: 0, y: 0 }, newSegments[0].direction, this.stepSize);
                newChain.segments = newSegments;

                return newChain;
            }

            splitAt(index) {
                if (index <= 0 || index >= this.segments.length) return [this];

                const leftSegments = this.segments.slice(0, index);
                const rightSegments = this.segments.slice(index + 1);

                if (rightSegments.length > 0) {
                    rightSegments[0].isHead = true;
                    rightSegments[0].emoji = CURRENT_LEVEL_EMOJI;
                }

                const chains = [];

                if (leftSegments.length > 0) {
                    const leftChain = new MegapedeChain(0, { x: 0, y: 0 }, 1, this.stepSize);
                    leftChain.segments = leftSegments;
                    leftChain.delay = this.delay;
                    chains.push(leftChain);
                }

                if (rightSegments.length > 0) {
                    const rightChain = new MegapedeChain(0, { x: 0, y: 0 }, 1, this.stepSize);
                    rightChain.segments = rightSegments;
                    rightChain.delay = this.delay;
                    chains.push(rightChain);
                }

                return chains;
            }
        }

        // Spider Class
        class Spider {
            constructor(position, speed, size) {
                this.position = position;
                this.direction = { x: Math.random() > 0.5 ? 1 : -1, y: 0 };
                const level = CURRENT_GAME_LEVEL || 1;
                this.speed = speed * (BASE_SPIDER_SPEED + (level - 1) * SPEED_INCREASE_PER_LEVEL);
                this.size = size;
                this.isAlive = true;
                this.color = "#FF0000";
                this.targetBlock = null;
                this.targetSection = null;
                this.targetSections = [];
                this.chewingTime = 0;
                this.chewingDuration = 350;
                this.isChewing = false;
                this.lastDirectionChange = 0;
                this.directionChangeDelay = 1000;
                this.chaseSpeed = 0.5;
                this.isAtBottom = false;
                this.aggressiveChaseSpeed = 1.5;
                this.lastDirectionChange = Date.now();
            }

            update(bounds, obstacles, mushrooms, playerPosition) {
                if (this.isChewing && this.targetBlock && this.targetSections.length > 0) {
                    this.chewingTime += 16;

                    if (this.chewingTime >= this.chewingDuration) {
                        this.isChewing = false;
                        this.chewingTime = 0;

                        const mushroom = mushrooms.find(
                            (m) => m.position.x === this.targetBlock.x && m.position.y === this.targetBlock.y,
                        );

                        if (mushroom) {
                            for (const sectionIndex of this.targetSections) {
                                if (sectionIndex >= 0 && sectionIndex < 16 && mushroom.sections[sectionIndex]) {
                                    mushroom.sections[sectionIndex] = false;
                                    mushroom.health--;
                                }
                            }
                        }

                        this.targetBlock = null;
                        this.targetSections = [];

                        const dirToPlayer = {
                            x: playerPosition.x - this.position.x,
                            y: playerPosition.y - this.position.y
                        };
                        
                        dirToPlayer.x += (Math.random() * 0.6 - 0.3);
                        dirToPlayer.y += (Math.random() * 0.6 - 0.3);
                        
                        const length = Math.sqrt(dirToPlayer.x * dirToPlayer.x + dirToPlayer.y * dirToPlayer.y);
                        if (length > 0) {
                            this.direction = {
                                x: dirToPlayer.x / length,
                                y: dirToPlayer.y / length
                            };
                        } else {
                            this.direction = { 
                                x: Math.random() * 2 - 1, 
                                y: Math.random() * 2 - 1 
                            };
                        }
                        
                        this.position.x += this.direction.x * 2;
                        this.position.y += this.direction.y * 2;
                    }
                    return;
                }

                const blockInfo = this.findBlockInPath(mushrooms);

                if (blockInfo) {
                    if (this.direction.y > 0 && blockInfo.direction === "below") {
                        this.isChewing = true;
                        this.targetBlock = { x: blockInfo.mushroom.position.x, y: blockInfo.mushroom.position.y };

                        this.targetSections = [blockInfo.sectionIndex];

                        const row = Math.floor(blockInfo.sectionIndex / 4);
                        const col = blockInfo.sectionIndex % 4;

                        if (col < 3 && blockInfo.mushroom.sections[row * 4 + col + 1]) {
                            this.targetSections.push(row * 4 + col + 1);
                        }
                        else if (col > 0 && blockInfo.mushroom.sections[row * 4 + col - 1]) {
                            this.targetSections.push(row * 4 + col - 1);
                        }
                        else if (row < 3 && blockInfo.mushroom.sections[(row + 1) * 4 + col]) {
                            this.targetSections.push((row + 1) * 4 + col);
                        }
                        else if (row > 0 && blockInfo.mushroom.sections[(row - 1) * 4 + col]) {
                            this.targetSections.push((row - 1) * 4 + col);
                        }

                        return;
                    } else {
                        this.isChewing = true;
                        this.targetBlock = { x: blockInfo.mushroom.position.x, y: blockInfo.mushroom.position.y };
                        this.targetSections = [blockInfo.sectionIndex];
                        
                        const row = Math.floor(blockInfo.sectionIndex / 4);
                        const col = blockInfo.sectionIndex % 4;
                        
                        const neighbors = [
                            row * 4 + ((col + 1) % 4),
                            row * 4 + ((col - 1 + 4) % 4),
                            ((row + 1) % 4) * 4 + col,
                            ((row - 1 + 4) % 4) * 4 + col
                        ];
                        
                        for (const neighbor of neighbors) {
                            if (blockInfo.mushroom.sections[neighbor]) {
                                this.targetSections.push(neighbor);
                                break;
                            }
                        }
                        this.lastDirectionChange = Date.now();
                        return;
                    }
                }

                const now = Date.now();
                this.isAtBottom = this.position.y >= bounds.y - BORDER_WIDTH - this.size - 10;

                if (this.isAtBottom) {
                    const dirToPlayer = {
                        x: playerPosition.x - this.position.x,
                        y: playerPosition.y - this.position.y,
                    };

                    const length = Math.sqrt(dirToPlayer.x * dirToPlayer.x + dirToPlayer.y * dirToPlayer.y);
                    if (length > 0) {
                        dirToPlayer.x /= length;
                        dirToPlayer.y /= length;
                    }

                    if (Math.random() < 0.3 || now - this.lastDirectionChange > this.directionChangeDelay) {
                        this.direction = {
                            x: dirToPlayer.x,
                            y: dirToPlayer.y < 0 ? -1 : 0,
                        };
                        this.lastDirectionChange = now;
                    }
                }
                else {
                    const dirToPlayer = {
                        x: playerPosition.x - this.position.x,
                        y: playerPosition.y - this.position.y
                    };
                    const distance = Math.sqrt(dirToPlayer.x * dirToPlayer.x + dirToPlayer.y * dirToPlayer.y);
                    
                    if (distance > 0) {
                        dirToPlayer.x /= distance;
                        dirToPlayer.y /= distance;
                    }
                    
                    if (now - this.lastDirectionChange > this.directionChangeDelay && Math.random() < 0.5) {
                        this.direction = {
                            x: dirToPlayer.x + (Math.random() * 0.4 - 0.2),
                            y: dirToPlayer.y + (Math.random() * 0.4 - 0.2)
                        };
                        
                        const length = Math.sqrt(this.direction.x * this.direction.x + this.direction.y * this.direction.y);
                        if (length > 0) {
                            this.direction.x /= length;
                            this.direction.y /= length;  
                        }
                        
                        this.lastDirectionChange = now;
                    }
                    else if (now - this.lastDirectionChange > this.directionChangeDelay && Math.random() < 0.02) {
                        if (this.direction.y === 0) {
                            this.direction = { x: 0, y: 1 };
                        } else if (this.direction.y > 0) {
                            this.direction = { x: Math.random() > 0.5 ? 1 : -1, y: 0 };
                        } else {
                            this.direction = { x: Math.random() > 0.5 ? 1 : -1, y: 0 };
                        }
                        this.lastDirectionChange = now;
                    }
                }

                const prevPosition = { ...this.position };

                const actualSpeed = this.isAtBottom
                    ? this.aggressiveChaseSpeed
                    : this.direction.y < 0
                        ? this.chaseSpeed
                        : this.speed;

                this.position.x += this.direction.x * actualSpeed;
                this.position.y += this.direction.y * actualSpeed;

                if (this.position.x < BORDER_WIDTH) {
                    this.position.x = BORDER_WIDTH;
                    this.direction.x *= -1;
                } else if (this.position.x > bounds.x - BORDER_WIDTH - this.size) {
                    this.position.x = bounds.x - BORDER_WIDTH - this.size;
                    this.direction.x *= -1;
                }

                if (this.position.y >= bounds.y - BORDER_WIDTH - this.size) {
                    this.position.y = bounds.y - BORDER_WIDTH - this.size;
                    if (this.direction.y > 0) {
                        this.direction = { x: Math.random() > 0.5 ? 1 : -1, y: 0 };
                    }
                }

                if (this.position.y <= BORDER_WIDTH) {
                    this.position.y = BORDER_WIDTH;
                    this.direction = { x: Math.random() > 0.5 ? 1 : -1, y: Math.random() > 0.7 ? 0 : 1 };
                }

                for (let i = 0; i < mushrooms.length; i++) {
                    const mushroom = mushrooms[i];
                    const collision = this.checkCollisionWithMushroom(mushroom);
                    
                    if (collision.collided) {
                        this.isChewing = true;
                        this.targetBlock = { x: mushroom.position.x, y: mushroom.position.y };
                        this.chewingTime = 0;
                        
                        let activeSections = [];
                        for (let j = 0; j < mushroom.sections.length; j++) {
                            if (mushroom.sections[j]) {
                                activeSections.push(j);
                            }
                        }
                        
                        if (activeSections.length > 0) {
                            this.targetSections = [];
                            for (let j = 0; j < Math.min(3, activeSections.length); j++) {
                                const randomIndex = Math.floor(Math.random() * activeSections.length);
                                this.targetSections.push(activeSections[randomIndex]);
                                activeSections.splice(randomIndex, 1);
                            }
                            return;
                        }
                        
                        this.position = prevPosition;

                        const dirToPlayer = {
                            x: playerPosition.x - this.position.x,
                            y: playerPosition.y - this.position.y
                        };
                        
                        const length = Math.sqrt(dirToPlayer.x * dirToPlayer.x + dirToPlayer.y * dirToPlayer.y);
                        if (length > 0) {
                            this.direction = {
                                x: (dirToPlayer.x / length) + (Math.random() * 0.8 - 0.4),
                                y: (dirToPlayer.y / length) + (Math.random() * 0.8 - 0.4)
                            };
                        } else {
                            this.direction = { 
                                x: Math.random() * 2 - 1, 
                                y: Math.random() * 2 - 1 
                            };
                        }
                        
                        const dirLength = Math.sqrt(this.direction.x * this.direction.x + this.direction.y * this.direction.y);
                        if (dirLength > 0) {
                            this.direction.x /= dirLength;
                            this.direction.y /= dirLength;
                        }

                        this.lastDirectionChange = Date.now();
                        break;
                    }
                }
            }

            checkCollisionWithMushroom(mushroom) {
                const spiderRight = this.position.x + this.size;
                const spiderBottom = this.position.y + this.size;
                const mushroomRight = mushroom.position.x + mushroom.size;
                const mushroomBottom = mushroom.position.y + mushroom.size;

                if (
                    this.position.x < mushroomRight &&
                    spiderRight > mushroom.position.x &&
                    this.position.y < mushroomBottom &&
                    spiderBottom > mushroom.position.y
                ) {
                    const destroyChance = this.isAtBottom ? 0.6 : 0.3;
                    const shouldDestroy = Math.random() < destroyChance;

                    return { collided: true, destroyed: shouldDestroy };
                }
                return { collided: false, destroyed: false };
            }

            findBlockInPath(mushrooms) {
                for (const mushroom of mushrooms) {
                    for (let i = 0; i < 16; i++) {
                        if (!mushroom.sections[i]) continue;

                        const sectionX = mushroom.position.x + (i % 4) * SECTION_SIZE;
                        const sectionY = mushroom.position.y + Math.floor(i / 4) * SECTION_SIZE;

                        if (
                            this.direction.y > 0 &&
                            this.position.x < sectionX + SECTION_SIZE &&
                            this.position.x + this.size > sectionX &&
                            this.position.y + this.size <= sectionY &&
                            this.position.y + this.size + this.speed >= sectionY
                        ) {
                            return { mushroom, sectionIndex: i, direction: "below" };
                        }

                        if (
                            this.direction.y < 0 &&
                            this.position.x < sectionX + SECTION_SIZE &&
                            this.position.x + this.size > sectionX &&
                            this.position.y >= sectionY + SECTION_SIZE &&
                            this.position.y - this.speed <= sectionY + SECTION_SIZE
                        ) {
                            return { mushroom, sectionIndex: i, direction: "above" };
                        }

                        if (
                            this.direction.x < 0 &&
                            this.position.y < sectionY + SECTION_SIZE &&
                            this.position.y + this.size > sectionY &&
                            this.position.x >= sectionX + SECTION_SIZE &&
                            this.position.x - this.speed <= sectionX + SECTION_SIZE
                        ) {
                            return { mushroom, sectionIndex: i, direction: "left" };
                        }

                        if (
                            this.direction.x > 0 &&
                            this.position.y < sectionY + SECTION_SIZE &&
                            this.position.y + this.size > sectionY &&
                            this.position.x + this.size <= sectionX &&
                            this.position.x + this.size + this.speed >= sectionX
                        ) {
                            return { mushroom, sectionIndex: i, direction: "right" };
                        }
                    }
                }
                return null;
            }
        }

        // Utility functions
        function createMushroomParticles(position, sectionIndex, colorSet) {
            const sectionX = position.x + (sectionIndex % 4) * SECTION_SIZE;
            const sectionY = position.y + Math.floor(sectionIndex / 4) * SECTION_SIZE;

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 1 + Math.random() * 3;
                const color = colorSet[Math.floor(Math.random() * colorSet.length)];

                gameState.particles.push({
                    position: {
                        x: sectionX + SECTION_SIZE / 2,
                        y: sectionY + SECTION_SIZE / 2,
                    },
                    velocity: {
                        x: Math.cos(angle) * speed,
                        y: Math.sin(angle) * speed,
                    },
                    size: 1 + Math.random() * 2,
                    color,
                    createdAt: Date.now(),
                    lifespan: 200 + Math.random() * 300,
                });
            }
        }

        function createMushroom(x, y) {
            let gridX = Math.floor(x / GRID_SIZE) * GRID_SIZE;
            let gridY = Math.floor(y / GRID_SIZE) * GRID_SIZE;
            
            if (gridX < BORDER_WIDTH + GRID_SIZE) {
                gridX = BORDER_WIDTH + GRID_SIZE;
            } else if (gridX > GAME_WIDTH - BORDER_WIDTH - MUSHROOM_SIZE - GRID_SIZE) {
                gridX = GAME_WIDTH - BORDER_WIDTH - MUSHROOM_SIZE - GRID_SIZE;
            }
            
            if (gridY < BORDER_WIDTH + GRID_SIZE) {
                gridY = BORDER_WIDTH + GRID_SIZE;
            } else if (gridY > GAME_HEIGHT - BOTTOM_BORDER_WIDTH - MUSHROOM_SIZE - GRID_SIZE) {
                gridY = GAME_HEIGHT - BOTTOM_BORDER_WIDTH - MUSHROOM_SIZE - GRID_SIZE;
            }

            const colorSet = EGG_COLORS[Math.floor(Math.random() * EGG_COLORS.length)];

            const mushroom = {
                position: { x: gridX, y: gridY },
                size: MUSHROOM_SIZE,
                health: 16,
                colorSet,
                sections: Array(16).fill(true),
            };

            gameState.mushrooms.push(mushroom);

            const key = `${Math.floor(gridX / GRID_SIZE)},${Math.floor(gridY / GRID_SIZE)}`;
            gameState.obstacleGrid.add(key);

            return mushroom;
        }

        function initGame() {
            gameState.gameStarted = true;
            gameState.gameOver = false;

            gameState.player = {
                position: {
                    x: GAME_WIDTH / 2 - PLAYER_SIZE / 2,
                    y: GAME_HEIGHT - PLAYER_SIZE * 2,
                },
                size: PLAYER_SIZE,
                speed: PLAYER_SPEED,
                color: "#00FFFF",
                energized: false,
                energyTimer: 0,
                killCount: 0,
                energyThreshold: 10,
                energyDuration: 5000,
                plasmaAmmo: 0,
                plasmaActive: false,
                plasmaTimer: 0,
                plasmaDuration: 5000,
            };
            gameState.bullets = [];
            gameState.mushrooms = [];
            gameState.particles = [];
            gameState.megapedeChains = [];
            gameState.spiders = [];
            gameState.powerUps = [];
            gameState.obstacleGrid = new Set();
            gameState.lastUpdateTime = Date.now();
            gameState.lastSpiderSpawnTime = Date.now();
            
            gameState.levelEmoji = EMOJI_HEADS[Math.floor(Math.random() * EMOJI_HEADS.length)];
            CURRENT_LEVEL_EMOJI = gameState.levelEmoji;
            CURRENT_GAME_LEVEL = gameState.level;

            const mushroomCount = 80 + gameState.level * 10;

            for (let i = 0; i < mushroomCount * 0.6; i++) {
                const mushroomX = Math.floor(Math.random() * (GAME_WIDTH - MUSHROOM_SIZE * 2 - BORDER_WIDTH * 2) + BORDER_WIDTH);
                const mushroomY = Math.floor(Math.random() * (GAME_HEIGHT / 2 - MUSHROOM_SIZE * 2) + BORDER_WIDTH);
                createMushroom(mushroomX, mushroomY);
            }

            for (let i = 0; i < mushroomCount * 0.4; i++) {
                const mushroomX = Math.floor(Math.random() * (GAME_WIDTH - MUSHROOM_SIZE * 2 - BORDER_WIDTH * 2) + BORDER_WIDTH);
                const mushroomY = Math.floor(Math.random() * (GAME_HEIGHT / 2) + GAME_HEIGHT / 2);
                createMushroom(mushroomX, mushroomY);
            }

            const bonusSegments = gameState.level - 1;
            const segmentCount = BASE_SEGMENT_COUNT + bonusSegments;
            
            const startX = Math.random() > 0.5 ? BORDER_WIDTH : GAME_WIDTH - BORDER_WIDTH - SEGMENT_SIZE;
            const direction = startX === BORDER_WIDTH ? 1 : -1;
            const startY = SEGMENT_SIZE + BORDER_WIDTH;

            const megapedeChain = new MegapedeChain(segmentCount, { x: startX, y: startY }, direction, SEGMENT_SIZE);
            gameState.megapedeChains.push(megapedeChain);

            gameState.lastSpiderSpawnTime = Date.now();
            CURRENT_GAME_LEVEL = gameState.level;
        }

        function startGame() {
            gameState.score = 0;
            gameState.level = 1;
            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('gameOverScreen').classList.add('hidden');
            initGame();
            gameLoop();
        }

        function gameLoop() {
            if (gameState.gameOver) {
                document.getElementById('gameOverScreen').classList.remove('hidden');
                document.getElementById('finalScore').textContent = `Final Score: ${gameState.score}`;
                return;
            }

            // Clear canvas
            const bgGradient = ctx.createLinearGradient(0, 0, 0, GAME_HEIGHT);
            const timeOffset = Date.now() / 10000;
            
            bgGradient.addColorStop(0, BG_GRADIENT_COLORS[0]);
            bgGradient.addColorStop(0.5 + Math.sin(timeOffset) * 0.2, BG_GRADIENT_COLORS[1]);
            bgGradient.addColorStop(1, BG_GRADIENT_COLORS[2]);
            
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            
            // Add starfield
            const starCount = 50;
            for (let i = 0; i < starCount; i++) {
                const x = Math.sin(i * 7.5 + timeOffset) * GAME_WIDTH/2 + GAME_WIDTH/2;
                const y = Math.cos(i * 3.3 + timeOffset * 1.2) * GAME_HEIGHT/2 + GAME_HEIGHT/2;
                const size = 0.5 + Math.sin(i + timeOffset * 2) * 0.5;
                
                const alpha = 0.5 + Math.sin(i * 0.5 + timeOffset * 3) * 0.5;
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw borders
            ctx.lineWidth = BORDER_WIDTH;
            const borderGradient = ctx.createLinearGradient(0, 0, GAME_WIDTH, GAME_HEIGHT);
            borderGradient.addColorStop(0, "#4D88FF");
            borderGradient.addColorStop(0.5, "#0044CC");
            borderGradient.addColorStop(1, "#002266");
            
            ctx.strokeStyle = borderGradient;
            
            // Top border
            ctx.beginPath();
            ctx.lineWidth = BORDER_WIDTH;
            ctx.moveTo(0, BORDER_WIDTH/2);
            ctx.lineTo(GAME_WIDTH, BORDER_WIDTH/2);
            ctx.stroke();
            
            // Left border
            ctx.beginPath();
            ctx.lineWidth = BORDER_WIDTH;
            ctx.moveTo(BORDER_WIDTH/2, 0);
            ctx.lineTo(BORDER_WIDTH/2, GAME_HEIGHT);
            ctx.stroke();
            
            // Right border
            ctx.beginPath();
            ctx.lineWidth = BORDER_WIDTH;
            ctx.moveTo(GAME_WIDTH - BORDER_WIDTH/2, 0);
            ctx.lineTo(GAME_WIDTH - BORDER_WIDTH/2, GAME_HEIGHT);
            ctx.stroke();
            
            // Bottom border
            ctx.beginPath();
            ctx.lineWidth = BOTTOM_BORDER_WIDTH;
            ctx.moveTo(0, GAME_HEIGHT - BOTTOM_BORDER_WIDTH/2);
            ctx.lineTo(GAME_WIDTH, GAME_HEIGHT - BOTTOM_BORDER_WIDTH/2);
            ctx.stroke();
            
            // Draw text in bottom border
            ctx.fillStyle = "#FFFFFF";
            ctx.font = "12px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText("Use arrow keys to move and spacebar to shoot", GAME_WIDTH/2, GAME_HEIGHT - BOTTOM_BORDER_WIDTH/2);
            
            // Draw score and level
            ctx.font = "bold 18px Arial";
            ctx.fillStyle = "white";
            ctx.textAlign = "left";
            ctx.fillText(`Score: ${gameState.score}`, 20, GAME_HEIGHT - BOTTOM_BORDER_WIDTH/2);
            
            ctx.textAlign = "right";
            ctx.fillText(`Level: ${gameState.level}`, GAME_WIDTH - 20, GAME_HEIGHT - BOTTOM_BORDER_WIDTH/2);

            // Update player position
            if (gameState.keys.left) {
                gameState.player.position.x -= gameState.player.speed;
            }
            if (gameState.keys.right) {
                gameState.player.position.x += gameState.player.speed;
            }
            if (gameState.keys.up) {
                gameState.player.position.y -= gameState.player.speed;
            }
            if (gameState.keys.down) {
                gameState.player.position.y += gameState.player.speed;
            }

            // Keep player within bounds
            gameState.player.position.x = Math.max(
                BORDER_WIDTH,
                Math.min(canvas.width - BORDER_WIDTH - gameState.player.size, gameState.player.position.x),
            );
            gameState.player.position.y = Math.max(
                canvas.height / 2,
                Math.min(canvas.height - BOTTOM_BORDER_WIDTH - gameState.player.size, gameState.player.position.y),
            );

            // Check for energy expiration
            if (gameState.player.energized && Date.now() > gameState.player.energyTimer + gameState.player.energyDuration) {
                gameState.player.energized = false;
            }
            
            // Check for plasma expiration
            if (gameState.player.plasmaActive && Date.now() > gameState.player.plasmaTimer + gameState.player.plasmaDuration) {
                gameState.player.plasmaActive = false;
            }

            // Shoot bullets
            const currentTime = Date.now();
            if ((gameState.autoShootEnabled || gameState.keys.space) && currentTime - gameState.lastShootTime > SHOOT_COOLDOWN) {
                const isPlasma = gameState.player.plasmaActive;
                const bulletSize = isPlasma ? 25 : BULLET_SIZE;
                const bulletSpeed = isPlasma ? BULLET_SPEED * 0.7 : BULLET_SPEED;
                
                gameState.bullets.push({
                    position: {
                        x: gameState.player.position.x + gameState.player.size / 2 - bulletSize / 2,
                        y: gameState.player.position.y - bulletSize
                    },
                    size: bulletSize,
                    speed: bulletSpeed,
                    active: true,
                    isPlasma: isPlasma
                });
                gameState.lastShootTime = currentTime;
            }

            // Draw power-ups
            gameState.powerUps.forEach((powerUp) => {
                if (powerUp.active) {
                    powerUp.pulsePhase = (powerUp.pulsePhase + 0.1) % (Math.PI * 2);
                    
                    const pulseSize = 1 + Math.sin(powerUp.pulsePhase) * 0.2;
                    
                    ctx.fillStyle = "rgba(0, 170, 255, 0.3)";
                    ctx.beginPath();
                    ctx.arc(
                        powerUp.position.x + powerUp.size / 2,
                        powerUp.position.y + powerUp.size / 2,
                        powerUp.size * pulseSize,
                        0,
                        Math.PI * 2
                    );
                    ctx.fill();
                    
                    ctx.fillStyle = "#00AAFF";
                    ctx.beginPath();
                    ctx.arc(
                        powerUp.position.x + powerUp.size / 2,
                        powerUp.position.y + powerUp.size / 2,
                        powerUp.size / 3,
                        0,
                        Math.PI * 2
                    );
                    ctx.fill();
                    
                    ctx.strokeStyle = "white";
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    const centerX = powerUp.position.x + powerUp.size / 2;
                    const centerY = powerUp.position.y + powerUp.size / 2;
                    ctx.moveTo(centerX - 3, centerY - 6);
                    ctx.lineTo(centerX + 3, centerY - 2);
                    ctx.lineTo(centerX - 2, centerY + 1);
                    ctx.lineTo(centerX + 4, centerY + 6);
                    ctx.stroke();
                }
            });

            // Update bullets
            gameState.bullets.forEach((bullet) => {
                bullet.position.y -= bullet.speed;

                if (bullet.position.y < BORDER_WIDTH) {
                    bullet.active = false;
                }

                // Check collisions with power-ups
                gameState.powerUps.forEach((powerUp, index) => {
                    if (!powerUp.active) return;
                    
                    const playerCenterX = gameState.player.position.x + gameState.player.size / 2;
                    const playerCenterY = gameState.player.position.y + gameState.player.size / 2;
                    const powerUpCenterX = powerUp.position.x + powerUp.size / 2;
                    const powerUpCenterY = powerUp.position.y + powerUp.size / 2;
                    
                    const dx = playerCenterX - powerUpCenterX;
                    const dy = playerCenterY - powerUpCenterY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    const collisionRadius = (gameState.player.size / 2 + powerUp.size / 2) * 1.6;
                    
                    if (distance < collisionRadius) {
                        powerUp.active = false;
                        
                        if (powerUp.type === 'plasma') {
                            gameState.player.plasmaActive = true;
                            gameState.player.plasmaTimer = Date.now();
                            
                            gameState.powerUps.splice(index, 1);
                            
                            for (let i = 0; i < 15; i++) {
                                gameState.particles.push({
                                    position: { ...powerUp.position },
                                    velocity: {
                                        x: (Math.random() - 0.5) * 5,
                                        y: (Math.random() - 0.5) * 5
                                    },
                                    size: 3,
                                    color: '#00AAFF',
                                    lifespan: 1000,
                                    createdAt: Date.now()
                                });
                            }
                        }
                    }
                });

                // Check collision with mushrooms
                gameState.mushrooms.forEach((mushroom) => {
                    for (let i = 0; i < 16; i++) {
                        if (mushroom.sections[i]) {
                            const sectionX = mushroom.position.x + (i % 4) * SECTION_SIZE;
                            const sectionY = mushroom.position.y + Math.floor(i / 4) * SECTION_SIZE;

                            const bulletCenterX = bullet.position.x + bullet.size / 2;
                            const bulletCenterY = bullet.position.y + bullet.size / 2;
                            const mushroomSectionCenterX = sectionX + SECTION_SIZE / 2;
                            const mushroomSectionCenterY = sectionY + SECTION_SIZE / 2;

                            const hitRadius = bullet.isPlasma ? BULLET_RADIUS * 1.5 : BULLET_RADIUS;
                            const dx = bulletCenterX - mushroomSectionCenterX;
                            const dy = bulletCenterY - mushroomSectionCenterY;
                            const distance = Math.sqrt(dx * dx + dy * dy);

                            if (bullet.active && distance < hitRadius) {
                                bullet.active = false;
                                mushroom.sections[i] = false;
                                
                                if (bullet.isPlasma) {
                                    mushroom.health -= 3;
                                } else {
                                    mushroom.health--;
                                }

                                createMushroomParticles(mushroom.position, i, mushroom.colorSet);

                                const adjacentSections = [];
                                const row = Math.floor(i / 4);
                                const col = i % 4;

                                if (col < 3) adjacentSections.push(row * 4 + col + 1);
                                if (col > 0) adjacentSections.push(row * 4 + col - 1);
                                if (row < 3) adjacentSections.push((row + 1) * 4 + col);
                                if (row > 0) adjacentSections.push((row - 1) * 4 + col);

                                const randomAdjacentIndex = Math.floor(Math.random() * adjacentSections.length);
                                const adjacentSectionIndex = adjacentSections[randomAdjacentIndex];

                                if (adjacentSectionIndex !== undefined && mushroom.sections[adjacentSectionIndex]) {
                                    mushroom.sections[adjacentSectionIndex] = false;
                                    mushroom.health--;
                                    createMushroomParticles(mushroom.position, adjacentSectionIndex, mushroom.colorSet);
                                }

                                if (mushroom.health <= 0) {
                                    const key = `${Math.floor(mushroom.position.x / GRID_SIZE)},${Math.floor(mushroom.position.y / GRID_SIZE)}`;
                                    gameState.obstacleGrid.delete(key);
                                    gameState.score += 10;
                                }

                                break;
                            }
                        }
                    }
                });

                // Check collision with megapede segments
                gameState.megapedeChains.forEach((chain, chainIndex) => {
                    chain.segments.forEach((segment, segmentIndex) => {
                        if (bullet.active && segment.isAlive) {
                            const distX = segment.position.x + SEGMENT_SIZE / 2 - (bullet.position.x + bullet.size / 2);
                            const distY = segment.position.y + SEGMENT_SIZE / 2 - (bullet.position.y + bullet.size / 2);
                            const distance = Math.sqrt(distX * distX + distY * distY);

                            const hitRadius = bullet.isPlasma ? BULLET_RADIUS * 1.5 : BULLET_RADIUS;
                            if (distance < hitRadius + SEGMENT_SIZE / 2) {
                                bullet.active = false;

                                if (segment.isHead) {
                                    const colorSet = EGG_COLORS[Math.floor(Math.random() * EGG_COLORS.length)];
                                    const mushroom = {
                                        position: { ...segment.position },
                                        size: MUSHROOM_SIZE,
                                        health: 16,
                                        colorSet,
                                        sections: Array(16).fill(true),
                                    };
                                    gameState.mushrooms.push(mushroom);

                                    const key = `${Math.floor(segment.position.x / GRID_SIZE)},${Math.floor(segment.position.y / GRID_SIZE)}`;
                                    gameState.obstacleGrid.add(key);

                                    segment.takeDamage();

                                    if (segment.isArmored) {
                                        for (let i = 0; i < 5; i++) {
                                            gameState.particles.push({
                                                position: {
                                                    x: bullet.position.x,
                                                    y: bullet.position.y,
                                                },
                                                velocity: {
                                                    x: (Math.random() - 0.5) * 3,
                                                    y: (Math.random() - 0.5) * 3,
                                                },
                                                size: PARTICLE_SIZE,
                                                color: "#FFD700",
                                                lifespan: 500,
                                                createdAt: Date.now(),
                                            });
                                        }
                                    }
                                    
                                    if (segmentIndex < chain.segments.length - 1) {
                                        const newChain = chain.createNewChainFromSegments(segmentIndex + 1);
                                        if (newChain) {
                                            gameState.megapedeChains.push(newChain);
                                        }
                                    }

                                    chain.segments = chain.segments.filter((s) => s.isAlive);

                                    gameState.score += 150;
                                    gameState.player.killCount += 2;
                                }
                                else {
                                    const wasDestroyed = segment.takeDamage();

                                    if (segment.isArmored && !wasDestroyed) {
                                        for (let i = 0; i < 5; i++) {
                                            gameState.particles.push({
                                                position: {
                                                    x: bullet.position.x,
                                                    y: bullet.position.y,
                                                },
                                                velocity: {
                                                    x: (Math.random() - 0.5) * 3,
                                                    y: (Math.random() - 0.5) * 3,
                                                },
                                                size: PARTICLE_SIZE,
                                                color: "#FFD700",
                                                lifespan: 500,
                                                createdAt: Date.now(),
                                            });
                                        }

                                        gameState.score += 25;
                                    }

                                    if (wasDestroyed) {
                                        const colorSet = EGG_COLORS[Math.floor(Math.random() * EGG_COLORS.length)];
                                        const mushroom = {
                                            position: { ...segment.position },
                                            size: MUSHROOM_SIZE,
                                            health: 16,
                                            colorSet,
                                            sections: Array(16).fill(true),
                                        };
                                        gameState.mushrooms.push(mushroom);

                                        const key = `${Math.floor(segment.position.x / GRID_SIZE)},${Math.floor(segment.position.y / GRID_SIZE)}`;
                                        gameState.obstacleGrid.add(key);

                                        if (segmentIndex > 0 && segmentIndex < chain.segments.length - 1) {
                                            const newChains = chain.splitAt(segmentIndex);
                                            gameState.megapedeChains.splice(chainIndex, 1, ...newChains);
                                        }

                                        gameState.score += 100;
                                        gameState.player.killCount++;
                                    }
                                }

                                if (gameState.player.killCount >= gameState.player.energyThreshold) {
                                    gameState.player.energized = true;
                                    gameState.player.energyTimer = Date.now();
                                    gameState.player.killCount = 0;
                                    gameState.player.color = "#FF9900";
                                }
                            }
                        }
                    });
                });

                // Check collision with spiders
                gameState.spiders.forEach((spider) => {
                    if (
                        bullet.active &&
                        spider.isAlive &&
                        bullet.position.x < spider.position.x + spider.size &&
                        bullet.position.x + bullet.size > spider.position.x &&
                        bullet.position.y < spider.position.y + spider.size &&
                        bullet.position.y + bullet.size > spider.position.y
                    ) {
                        bullet.active = false;
                        spider.isAlive = false;
                        gameState.score += 300;
                        gameState.player.killCount += 2;
                    }
                });
            });

            // Remove inactive bullets
            gameState.bullets = gameState.bullets.filter((bullet) => bullet.active);

            // Remove destroyed mushrooms
            gameState.mushrooms = gameState.mushrooms.filter((mushroom) => mushroom.health > 0);

            // Update and draw particles
            const particleNow = Date.now();
            gameState.particles.forEach((particle) => {
                const particleAge = particleNow - particle.createdAt;
                const ageRatio = particleAge / particle.lifespan;
                
                if (ageRatio > 0.9) return;
                
                const alpha = 1 - ageRatio;
                
                ctx.globalAlpha = alpha;
                ctx.fillStyle = particle.color;
                
                ctx.beginPath();
                ctx.arc(
                    particle.position.x + particle.size / 2,
                    particle.position.y + particle.size / 2,
                    Math.max(0.1, particle.size * (1 - ageRatio * 0.5)),
                    0,
                    Math.PI * 2
                );
                ctx.fill();
            });
            ctx.globalAlpha = 1;

            // Draw mushrooms
            gameState.mushrooms.forEach((mushroom) => {
                for (let i = 0; i < 16; i++) {
                    if (mushroom.sections[i]) {
                        const row = Math.floor(i / 4);
                        const col = i % 4;
                        
                        let offsetX = 0;
                        if (row === 1) offsetX = -SECTION_SIZE * 0.1;
                        if (row === 2) offsetX = -SECTION_SIZE * 0.1;
                        
                        const sectionX = mushroom.position.x + col * SECTION_SIZE + offsetX;
                        const sectionY = mushroom.position.y + row * SECTION_SIZE;
                        
                        const sectionCenterX = sectionX + SECTION_SIZE / 2;
                        const sectionCenterY = sectionY + SECTION_SIZE / 2;

                        const colorIndex = (i % 2) + (Math.floor(i / 4) % 2) * 2;
                        ctx.fillStyle = mushroom.colorSet[colorIndex % mushroom.colorSet.length];
                        
                        ctx.beginPath();
                        
                        let sizeMultiplier = 1.0;
                        if (row === 0) sizeMultiplier = 0.9;
                        if (row === 3) sizeMultiplier = 0.9;
                        if (col === 0 || col === 3) sizeMultiplier *= 0.95;
                        if (col === 1 || col === 2) sizeMultiplier *= 1.05;
                        
                        ctx.arc(
                            sectionCenterX,
                            sectionCenterY,
                            (SECTION_SIZE / 2) * sizeMultiplier,
                            0,
                            Math.PI * 2
                        );
                        ctx.fill();
                        
                        if ((col === 1 || col === 2) && row === 1) {
                            ctx.fillStyle = "rgba(255, 255, 255, 0.3)";
                            ctx.beginPath();
                            ctx.arc(
                                sectionCenterX - SECTION_SIZE / 4,
                                sectionCenterY - SECTION_SIZE / 4,
                                SECTION_SIZE / 5,
                                0,
                                Math.PI * 2
                            );
                            ctx.fill();
                        }
                    }
                }
            });

            // Draw megapede body segments
            gameState.megapedeChains.forEach((chain) => {
                chain.segments.forEach((segment) => {
                    if (segment.isAlive && !segment.isHead) {
                        ctx.fillStyle = segment.color;
                        ctx.beginPath();
                        ctx.arc(
                            segment.position.x + SEGMENT_SIZE / 2,
                            segment.position.y + SEGMENT_SIZE / 2,
                            SEGMENT_SIZE / 2,
                            0,
                            Math.PI * 2,
                        );
                        ctx.fill();

                        if (segment.isArmored) {
                            const gradient = ctx.createRadialGradient(
                                segment.position.x + SEGMENT_SIZE / 2,
                                segment.position.y + SEGMENT_SIZE / 2,
                                0,
                                segment.position.x + SEGMENT_SIZE / 2,
                                segment.position.y + SEGMENT_SIZE / 2,
                                SEGMENT_SIZE / 2,
                            );
                            gradient.addColorStop(0, "#FFFFFF");
                            gradient.addColorStop(0.3, segment.color);
                            gradient.addColorStop(1, "#444444");

                            ctx.fillStyle = gradient;
                            ctx.beginPath();
                            ctx.arc(
                                segment.position.x + SEGMENT_SIZE / 2,
                                segment.position.y + SEGMENT_SIZE / 2,
                                SEGMENT_SIZE / 2,
                                0,
                                Math.PI * 2,
                            );
                            ctx.fill();

                            ctx.strokeStyle = "#FFD700";
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.arc(
                                segment.position.x + SEGMENT_SIZE / 2,
                                segment.position.y + SEGMENT_SIZE / 2,
                                SEGMENT_SIZE / 2 + 2,
                                0,
                                Math.PI * 2,
                            );
                            ctx.stroke();

                            ctx.fillStyle = "#FFFFFF";
                            ctx.font = "8px Arial";
                            ctx.textAlign = "center";
                            ctx.textBaseline = "middle";
                            ctx.fillText(
                                segment.armorLevel.toString(),
                                segment.position.x + SEGMENT_SIZE / 2,
                                segment.position.y + SEGMENT_SIZE / 2,
                            );
                        }
                    }
                });
            });

            // Draw megapede heads
            gameState.megapedeChains.forEach((chain) => {
                chain.segments.forEach((segment) => {
                    if (segment.isAlive && segment.isHead) {
                        if (segment.isArmored) {
                            ctx.fillStyle = "rgba(0, 100, 255, 0.5)";
                            
                            const glowRadius = SEGMENT_SIZE / 2 + 8;
                            const gradient = ctx.createRadialGradient(
                                segment.position.x + SEGMENT_SIZE / 2,
                                segment.position.y + SEGMENT_SIZE / 2,
                                0,
                                segment.position.x + SEGMENT_SIZE / 2,
                                segment.position.y + SEGMENT_SIZE / 2,
                                glowRadius
                            );
                            gradient.addColorStop(0, "rgba(0, 68, 255, 0.7)");
                            gradient.addColorStop(0.5, "rgba(0, 72, 255, 0.4)");
                            gradient.addColorStop(1, "rgba(255, 215, 0, 0)");

                            ctx.fillStyle = gradient;
                            ctx.beginPath();
                            ctx.arc(
                                segment.position.x + SEGMENT_SIZE / 2,
                                segment.position.y + SEGMENT_SIZE / 2,
                                glowRadius,
                                0,
                                Math.PI * 2,
                            );
                            ctx.fill();

                            ctx.strokeStyle = "#FFD700";
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.arc(
                                segment.position.x + SEGMENT_SIZE / 2,
                                segment.position.y + SEGMENT_SIZE / 2,
                                SEGMENT_SIZE / 2 + 4,
                                0,
                                Math.PI * 2,
                            );
                            ctx.stroke();
                        }

                        const emojiFactor = 1.4;
                        ctx.font = `${Math.floor(SEGMENT_SIZE * emojiFactor)}px Arial`;
                        ctx.textAlign = "center";
                        ctx.textBaseline = "middle";
                        ctx.fillText(segment.emoji, segment.position.x + SEGMENT_SIZE / 2, segment.position.y + SEGMENT_SIZE / 2);
                    }
                });
            });

            // Draw spiders
            gameState.spiders.forEach((spider) => {
                ctx.fillStyle = spider.color;
                ctx.fillRect(spider.position.x, spider.position.y, spider.size, spider.size);
                
                // Draw spider legs
                ctx.strokeStyle = spider.color;
                ctx.lineWidth = 2;

                // Top legs
                ctx.beginPath();
                ctx.moveTo(spider.position.x, spider.position.y);
                ctx.lineTo(spider.position.x - 10, spider.position.y - 8);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(spider.position.x + spider.size, spider.position.y);
                ctx.lineTo(spider.position.x + spider.size + 10, spider.position.y - 8);
                ctx.stroke();

                // Bottom legs
                ctx.beginPath();
                ctx.moveTo(spider.position.x, spider.position.y + spider.size);
                ctx.lineTo(spider.position.x - 10, spider.position.y + spider.size + 8);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(spider.position.x + spider.size, spider.position.y + spider.size);
                ctx.lineTo(spider.position.x + spider.size + 10, spider.position.y + spider.size + 8);
                ctx.stroke();

                // Draw chewing animation
                if (spider.isChewing && spider.targetBlock && spider.targetSections.length > 0) {
                    const progress = spider.chewingTime / spider.chewingDuration;
                    const chewSize = 4 + Math.sin(progress * Math.PI * 10) * 2;

                    ctx.fillStyle = "#FFFF00";

                    for (const sectionIndex of spider.targetSections) {
                        const sectionX = spider.targetBlock.x + (sectionIndex % 4) * SECTION_SIZE;
                        const sectionY = spider.targetBlock.y + Math.floor(sectionIndex / 4) * SECTION_SIZE;

                        ctx.fillRect(
                            sectionX + SECTION_SIZE / 2 - chewSize / 2,
                            sectionY + SECTION_SIZE / 2 - chewSize / 2,
                            chewSize,
                            chewSize,
                        );
                    }
                }
            });

            // Draw player
            ctx.save();
            ctx.shadowBlur = PLAYER_GLOW_RADIUS;
            ctx.shadowColor = GLOW_COLOR;
            
            ctx.fillStyle = gameState.player.energized ? "#FF3333" : gameState.player.color;
            
            const playerCenterX = gameState.player.position.x + gameState.player.size / 2;
            const playerCenterY = gameState.player.position.y + gameState.player.size / 2;
            
            // Draw player as triangle
            ctx.beginPath();
            ctx.moveTo(playerCenterX, gameState.player.position.y);
            ctx.lineTo(gameState.player.position.x + gameState.player.size, gameState.player.position.y + gameState.player.size);
            ctx.lineTo(playerCenterX, gameState.player.position.y + gameState.player.size * 0.85);
            ctx.lineTo(gameState.player.position.x, gameState.player.position.y + gameState.player.size);
            ctx.closePath();
            ctx.fill();
            
            // Draw engine flames when moving
            if (gameState.keys.left || gameState.keys.right || gameState.keys.up || gameState.keys.down) {
                ctx.beginPath();
                const flameHeight = 5 + Math.random() * 5;
                ctx.fillStyle = `rgba(255, ${Math.floor(100 + Math.random() * 155)}, 0, 0.8)`;
                ctx.moveTo(playerCenterX - 5, gameState.player.position.y + gameState.player.size * 0.85);
                ctx.lineTo(playerCenterX, gameState.player.position.y + gameState.player.size * 0.85 + flameHeight);
                ctx.lineTo(playerCenterX + 5, gameState.player.position.y + gameState.player.size * 0.85);
                ctx.closePath();
                ctx.fill();
            }
            
            ctx.restore();

            // Draw bullets
            gameState.bullets.forEach((bullet) => {
                if (bullet.isPlasma) {
                    ctx.fillStyle = "#00AAFF";
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = "#00AAFF";
                    
                    ctx.beginPath();
                    ctx.arc(
                        bullet.position.x + bullet.size / 2,
                        bullet.position.y + bullet.size / 2,
                        bullet.size * 0.8,
                        0,
                        Math.PI * 2
                    );
                    ctx.fillStyle = "rgba(0, 170, 255, 0.6)";
                    ctx.fill();
                } else {
                    ctx.fillStyle = "#FFFFFF";
                    ctx.shadowBlur = 0;
                }
                ctx.fillRect(bullet.position.x, bullet.position.y, bullet.size, bullet.size);
            });
            
            ctx.shadowBlur = 0;

            // Update megapede chains
            gameState.megapedeChains.forEach((chain) => {
                chain.update(GAME_WIDTH, GAME_HEIGHT, gameState.obstacleGrid);

                chain.segments.forEach((segment) => {
                    if (!segment.isAlive) return;

                    const playerCenterX = gameState.player.position.x + gameState.player.size / 2;
                    const playerCenterY = gameState.player.position.y + gameState.player.size / 2;
                    const segmentCenterX = segment.position.x + SEGMENT_SIZE / 2;
                    const segmentCenterY = segment.position.y + SEGMENT_SIZE / 2;
                    const dx = playerCenterX - segmentCenterX;
                    const dy = playerCenterY - segmentCenterY;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < gameState.player.size / 2 + SEGMENT_SIZE / 2) {
                        if (!gameState.player.energized) {
                            gameState.gameOver = true;
                        } else {
                            segment.isAlive = false;
                            gameState.score += 200;
                        }
                    }
                });
            });
            
            // Remove empty chains
            gameState.megapedeChains = gameState.megapedeChains
                .map((chain) => {
                    chain.segments = chain.segments.filter((segment) => segment.isAlive);
                    return chain;
                })
                .filter((chain) => chain.segments.length > 0);

            // Spawn spiders
            const now2 = Date.now();
            if (now2 - gameState.lastSpiderSpawnTime > Math.max(2000, 5000 - (gameState.level - 1) * 300)) {
                const maxSpiders = Math.min(5, 1 + Math.floor(gameState.level / 2));
                
                if (gameState.spiders.filter(s => s.isAlive).length < maxSpiders) {
                    const spiderX = Math.random() * (GAME_WIDTH - SPIDER_SIZE * 2) + SPIDER_SIZE;
                    const spiderY = BORDER_WIDTH;
                    
                    const spider = new Spider(
                        { x: spiderX, y: spiderY },
                        1.5,
                        SPIDER_SIZE
                    );
                    gameState.spiders.push(spider);
                }
                gameState.lastSpiderSpawnTime = now2;
            }

            // Spawn power-ups
            const powerUpTime = Date.now();
            if (powerUpTime - gameState.lastPowerUpSpawnTime > gameState.powerUpSpawnRate) {
                const powerUpSize = 40;
                const safeMargin = 10;
                const powerUpX = BORDER_WIDTH + safeMargin + Math.random() * (GAME_WIDTH - BORDER_WIDTH * 2 - powerUpSize - safeMargin * 2);
                const powerUpY = GAME_HEIGHT / 2 + safeMargin + Math.random() * (GAME_HEIGHT / 2 - BOTTOM_BORDER_WIDTH - powerUpSize - safeMargin * 2);
                
                gameState.powerUps.push({
                    position: { x: powerUpX, y: powerUpY },
                    size: 40,
                    type: 'plasma',
                    active: true,
                    timeCreated: powerUpTime,
                    pulsePhase: 0
                });
                
                gameState.lastPowerUpSpawnTime = powerUpTime;
            }

            // Update spiders
            gameState.spiders.forEach((spider) => {
                if (spider.isAlive) {
                    spider.update({ x: GAME_WIDTH, y: GAME_HEIGHT }, gameState.obstacleGrid, gameState.mushrooms, gameState.player.position);

                    if (
                        spider.position.x < gameState.player.position.x + gameState.player.size &&
                        spider.position.x + spider.size > gameState.player.position.x &&
                        spider.position.y < gameState.player.position.y + gameState.player.size &&
                        spider.position.y + spider.size > gameState.player.position.y
                    ) {
                        if (!gameState.player.energized) {
                            gameState.gameOver = true;
                        } else {
                            spider.isAlive = false;
                            gameState.score += 300;
                        }
                    }
                }
            });

            // Remove dead spiders
            gameState.spiders = gameState.spiders.filter((spider) => spider.isAlive);

            // Check if all megapede chains are destroyed
            if (gameState.megapedeChains.length === 0) {
                gameState.level++;
                CURRENT_GAME_LEVEL = gameState.level;
                initGame();
            }

            // Update energy indicator
            const energyIndicator = document.getElementById('energyIndicator');
            if (gameState.player.energized) {
                energyIndicator.className = 'energy-indicator energy-ready';
            } else if (gameState.player.plasmaActive) {
                energyIndicator.className = 'energy-indicator plasma-active';
            } else {
                energyIndicator.className = 'energy-indicator';
            }

            // Continue game loop
            if (gameState.gameStarted && !gameState.gameOver) {
                animationId = requestAnimationFrame(gameLoop);
            }
        }

        // Resize canvas on window resize
        function resizeCanvas() {
            const container = document.getElementById('gameContainer');
            const containerWidth = container.clientWidth;
            const maxWidth = Math.min(containerWidth, BASE_GAME_WIDTH);
            const aspectRatio = BASE_GAME_HEIGHT / BASE_GAME_WIDTH;
            const height = maxWidth * aspectRatio;
            
            canvas.width = BASE_GAME_WIDTH;
            canvas.height = BASE_GAME_HEIGHT;
            canvas.style.width = `${maxWidth}px`;
            canvas.style.height = `${height}px`;
            
            GAME_WIDTH = BASE_GAME_WIDTH;
            GAME_HEIGHT = BASE_GAME_HEIGHT;
            SCALE_FACTOR = maxWidth / BASE_GAME_WIDTH;
        }

        // Initialize game on page load
        window.addEventListener('load', () => {
            resizeCanvas();
            // Show start screen
            document.getElementById('startScreen').classList.remove('hidden');
        });

        window.addEventListener('resize', resizeCanvas);

        // Prevent scrolling on mobile
        document.addEventListener('touchmove', function(e) {
            e.preventDefault();
        }, { passive: false });

        // Prevent context menu
        document.addEventListener('contextmenu', function(e) {
            e.preventDefault();
        });
    </script>
</body>
</html>